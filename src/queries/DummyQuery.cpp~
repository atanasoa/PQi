/*
 * DummyQuery.cpp
 *
 *  Created on: Jan 31, 2013
 *      Author: atanasoa
 */

#include "queries/DummyQuery.h"
#include <stdio.h>
#include <fstream>
#include "tarch/parallel/Node.h"
#include <unordered_map>
int queries::DummyQuery::getScope(){
	return 0;

}
queries::DummyQuery::DummyQuery():
											_offset(0.0),
											_size(1.0),
											_resolution(11){
	int numberOfPoints=1;
	for(int i=0;i<DIMENSIONS;i++)
		numberOfPoints*=_resolution[i];



}

queries::DummyQuery::~DummyQuery(){

}


queries::DummyQuery::DummyQuery(
		tarch::la::Vector<DIMENSIONS,double> offset,
		tarch::la::Vector<DIMENSIONS,double> size,
		tarch::la::Vector<DIMENSIONS,int> resolution,
		int scope,
		int time):
																							_offset(offset),
																							_size(size),
																							_resolution(resolution),
																							_time(time){
	int dim=1;
	for(int i=0;i<DIMENSIONS;i++)
		dim*=_resolution[i];

}



bool queries::DummyQuery::intersectsWithQuery(const tarch::la::Vector<2,double> voxelOffset,const tarch::la::Vector<2,double> voxelSize){
	if(voxelOffset[0]<_offset[0]&&voxelOffset[1]<_offset[1])
		return voxelOffset[0]+voxelSize[0]>=_offset[0]&&voxelOffset[1]+voxelSize[1]>=_offset[1];
	else if(voxelOffset[0]>=_offset[0]&&voxelOffset[1]>=_offset[1])
		return (voxelOffset[0]<=_offset[0]+_size[0]&&voxelOffset[1]<=_offset[1]+_size[1]);
	return false;
}







bool queries::DummyQuery::intersectsWithQuery(const tarch::la::Vector<3,double> voxelOffset,const tarch::la::Vector<3,double> voxelSize){

	#ifdef Dim3
	return intersectsWithVoxel(_offset,_size,voxelOffset,voxelSize);
	#else
	return false;
	#endif
}

bool queries::DummyQuery::intersectsWithVoxel(
		const tarch::la::Vector<3,double> voxelOffset1,
		const tarch::la::Vector<3,double> voxelSize1,
		const tarch::la::Vector<3,double> voxelOffset2,
		const tarch::la::Vector<3,double> voxelSize2
	){

	 bool res=true;
        for(int i=0;i<3;i++)
		res=res&&(
			(voxelOffset1[i]>=voxelOffset2[i]&&voxelOffset1[i]<=voxelOffset2[i]+voxelSize2[i])||
			(voxelOffset1[i]+voxelSize1[i]>=voxelOffset2[i]&&voxelOffset1[i]+voxelSize1[i]<=voxelOffset2[i]+voxelSize2[i])||
			(voxelOffset2[i]>=voxelOffset1[i]&&voxelOffset2[i]<=voxelOffset1[i]+voxelSize1[i])||
			(voxelOffset2[i]+voxelSize2[i]>=voxelOffset1[i]&&voxelOffset2[i]+voxelSize2[i]<=voxelOffset1[i]+voxelSize1[i])
			);

	return res;
}
void  queries::DummyQuery::release(std::vector<queries::records::Answer>& answer){
		std::ofstream out;
		std::stringstream str;
		str<<"query_"<<tarch::parallel::Node::getInstance().getRank()<<"_"<<_time<<".vtk";
		out.open(str.str().c_str());
		double dx=_size[0]/(double)(_resolution[0]-1);
		double dy=_size[1]/(double)(_resolution[1]-1);
	#ifdef Dim3
		double dz=_size[2]/(double)(_resolution[2]-1);
	#endif
		const std::string HEADER =
				"# vtk DataFile Version 2.0\n "\
				"Generated by Peano2 output component $Revision: 1.2 $ Author: Atanas Atanasov\n "\
				"ASCII\n ";

		if ( (!out.fail()) && out.is_open() ) {

			out << HEADER << std::endl << std::endl;

			out << "DATASET STRUCTURED_POINTS" << std::endl
					<< "DIMENSIONS  "
					<< _resolution(0) << " "
					<< _resolution(1) << " "
	#ifdef Dim3
					<< _resolution(2) << ""
	#else
					<< 1
	#endif
					<< std::endl << std::endl;
			out << "ORIGIN "
					<< _offset(0) << " "
					<< _offset(1) << " "
	#ifdef Dim3
					<< _offset(2) << ""
	#else
					<< 0.0
	#endif
					<< std::endl << std::endl;
			out << "SPACING "
					<< dx << " "
					<< dy << " "
	#ifdef Dim3
					<< dz << ""
	#else
					<< 0
	#endif
					<< std::endl << std::endl;

	#ifdef Dim3
			out << "POINT_DATA " << _resolution[0]*_resolution[1]*_resolution[2] << std::endl << std::endl;
	#else
			out << "POINT_DATA " << _resolution[0]*_resolution[1] << std::endl << std::endl;
	#endif




			out << "SCALARS temp DOUBLE"<< std::endl;
			out << "LOOKUP_TABLE default" << std::endl;
			std::unordered_map<int,int> answerMap;
			for(unsigned int i=0;i<answer.size();i++)
				answerMap[answer[i].getDataIndex()]=i;
	#ifdef Dim3
			for (int i=0; i<_resolution[2]; i++) {

	#endif
				for (int j=0; j<_resolution[1]; j++) {
					for (int k=0; k<_resolution[0]; k++) {
	#ifdef Dim3
						if(answerMap.find(i*_resolution[1]*_resolution[0]+j*_resolution[0]+k)!=answerMap.end())
							out <<answer[answerMap[i*_resolution[1]*_resolution[0]+j*_resolution[0]+k]].getData() << std::endl;
						else
							out << 0.0 << std::endl;
	#else
						out << _data[j*_resolution[0]+k] << std::endl;
	#endif
					}


				}
	#ifdef Dim3
			}
	#endif

		}
}
void queries::DummyQuery::release(){
//	std::ofstream out;
//	std::stringstream str;
//	str<<"query_"<<tarch::parallel::Node::getInstance().getRank()<<"_"<<_time<<".vtk";
//	out.open(str.str().c_str());
//	double dx=_size[0]/(double)(_resolution[0]-1);
//	double dy=_size[1]/(double)(_resolution[1]-1);
//#ifdef Dim3
//	double dz=_size[2]/(double)(_resolution[2]-1);
//#endif
//	const std::string HEADER =
//			"# vtk DataFile Version 2.0\n "\
//			"Generated by Peano2 output component $Revision: 1.2 $ Author: Atanas Atanasov\n "\
//			"ASCII\n ";
//
//	if ( (!out.fail()) && out.is_open() ) {
//
//		out << HEADER << std::endl << std::endl;
//
//		out << "DATASET STRUCTURED_POINTS" << std::endl
//				<< "DIMENSIONS  "
//				<< _resolution(0) << " "
//				<< _resolution(1) << " "
//#ifdef Dim3
//				<< _resolution(2) << ""
//#else
//				<< 1
//#endif
//				<< std::endl << std::endl;
//		out << "ORIGIN "
//				<< _offset(0) << " "
//				<< _offset(1) << " "
//#ifdef Dim3
//				<< _offset(2) << ""
//#else
//				<< 0.0
//#endif
//				<< std::endl << std::endl;
//		out << "SPACING "
//				<< dx << " "
//				<< dy << " "
//#ifdef Dim3
//				<< dz << ""
//#else
//				<< 0
//#endif
//				<< std::endl << std::endl;
//
//#ifdef Dim3
//		out << "POINT_DATA " << _resolution[0]*_resolution[1]*_resolution[2] << std::endl << std::endl;
//#else
//		out << "POINT_DATA " << _resolution[0]*_resolution[1] << std::endl << std::endl;
//#endif
//
//
//
//
//		out << "SCALARS temp DOUBLE"<< std::endl;
//		out << "LOOKUP_TABLE default" << std::endl;
//#ifdef Dim3
//		for (int i=0; i<_resolution[2]; i++) {
//
//#endif
//			for (int j=0; j<_resolution[1]; j++) {
//				for (int k=0; k<_resolution[0]; k++) {
//#ifdef Dim3
//					out << _data[i*_resolution[1]*_resolution[0]+j*_resolution[0]+k] << std::endl;
//#else
//					out << _data[j*_resolution[0]+k] << std::endl;
//#endif
//				}
//
//
//			}
//#ifdef Dim3
//		}
//#endif
//
//	}
}
bool queries::DummyQuery::isInVoxel(
		const tarch::la::Vector<2,double> &voxelOffset,
		const tarch::la::Vector<2,double> &voxelSize,
		double x,
		double y){

	return x<=voxelOffset[0]+voxelSize[0]&&x>=voxelOffset[0]&&
			y<=voxelOffset[1]+voxelSize[1]&&y>=voxelOffset[1];
}

bool queries::DummyQuery::isInVoxel(
		const tarch::la::Vector<3,double> &voxelOffset,
		const tarch::la::Vector<3,double> &voxelSize,
		double x,
		double y,
		double z){

	return x<=voxelOffset[0]+voxelSize[0]&&x>=voxelOffset[0]&&
			y<=voxelOffset[1]+voxelSize[1]&&y>=voxelOffset[1]&&
			z<=voxelOffset[2]+voxelSize[2]&&z>=voxelOffset[2];
}
void queries::DummyQuery::setData(const tarch::la::Vector<2,double> &voxelOffset,const tarch::la::Vector<2,double> &voxelSize,double x){
	double dx=_size[0]/(double)(_resolution[0]-1);
	double dy=_size[1]/(double)(_resolution[1]-1);

	for(int i = 0 ;i<_resolution[1];i++)
		for(int j = 0;j<_resolution[0];j++)
		{
			if(isInVoxel(voxelOffset,voxelSize,_offset[0]+(double)j*dx,_offset[1]+(double)i*dy))
				;//;_data[i*_resolution[0]+j]=x;
		}
}

void queries::DummyQuery::fillAnswers(std::vector<queries::records::Answer>& answers){
	queries::records::Answer a;
	if(tarch::parallel::Node::getInstance().getRank()!=1)
			std::cout<<"rank:"<<tarch::parallel::Node::getInstance().getRank()<<","<<_data.size()<<std::endl;
	for(std::unordered_map< int,std::pair<double,double > >::iterator it=_data.begin();it!=_data.end();it++)
	{
		a.setData((*it).second.second);

		a.setPosition((*it).second.first);
		a.setDataIndex((*it).first);
		answers.push_back(a);
	}
	_data.clear();
}
void queries::DummyQuery::setData(const tarch::la::Vector<3,double> &voxelOffset,const tarch::la::Vector<3,double> &voxelSize,double x){
	tarch::la::Vector<3,double> d;
	d[0]=_size[0]/(double)(_resolution[0]-1);
	d[1]=_size[1]/(double)(_resolution[1]-1);
	d[2]=_size[2]/(double)(_resolution[2]-1);

	tarch::la::Vector<3,double> currentOff;
	for(int i = 0 ;i<_resolution[2];i++)
		for(int j = 0;j<_resolution[1];j++)
			for(int k = 0 ;k<_resolution[0];k++)
			{
				currentOff[0]=_offset[0]+(double)k*d[0];
				currentOff[1]=_offset[1]+(double)j*d[1];
				currentOff[2]=_offset[2]+(double)i*d[2];
				//std::cout<<"setting data on "<<tarch::parallel::Node::getInstance().getRank()<<std::endl;

				if(isInVoxel(
						currentOff,
						d,
						voxelOffset[0],voxelOffset[1],voxelOffset[2]
						)||
						isInVoxel(
								voxelOffset,
								voxelSize,
								currentOff[0],currentOff[1],currentOff[2]
						)
						){
					double ddx=(voxelOffset[0]-_offset[0]-(double)k*d[0]);
					double ddy=(voxelOffset[1]-_offset[1]-(double)j*d[1]);
					double ddz=(voxelOffset[2]-_offset[2]-(double)i*d[2]);

					double dist=ddx*ddx+ddy*ddy+ddz*ddz;
					std::unordered_map< int,std::pair<double,double > >::const_iterator got=_data.find(i*_resolution[1]*_resolution[0]+j*_resolution[0]+k);
					//if(tarch::parallel::Node::getInstance().getRank()!=1)
					if(got!=_data.end()){
						_data[i*_resolution[1]*_resolution[0]+j*_resolution[0]+k]=std::make_pair<double,double>(sqrt(dist),0);
						_data[i*_resolution[1]*_resolution[0]+j*_resolution[0]+k].second=x;
						_data[i*_resolution[1]*_resolution[0]+j*_resolution[0]+k].first=sqrt(dist);
					}else{
						if(sqrt(dist)<_data[i*_resolution[1]*_resolution[0]+j*_resolution[0]+k].first){
							_data[i*_resolution[1]*_resolution[0]+j*_resolution[0]+k].second=x;
							_data[i*_resolution[1]*_resolution[0]+j*_resolution[0]+k].first=sqrt(dist);
						}
					}

				}
			}
}
